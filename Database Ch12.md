# 저장 장치 관리 및 인덱싱

* 데이터베이스가 제공하는 고수준의 뷰도 하나 이상의 저장 장치에 비트로 저장됨
* 데이터베이스는 메모리와 저장장치에 읽고 쓰기를 반복함.
* 다양한 종류의 보조기억장치가 존재하며, RAID를 통해 데이터 손실 가능성을 최소화 한다.
* 효과적으로 데이터를 디스크에 배핑하는 다양한 방식이 존재한다.


# ch12. 물리적 저장 장치 시스템

* 실제로 데이터베이스 사용자는 논리 모델을 가장 중심적으로 사용.
* 사용자가 물리적인 시스템의 구현까지 사용하면 큰 부담.

## 12.1 물리적 저장 장치 매체 개요
* 데이터에 접근하는 속도, 저장장치의 데이터 단위당 비용, 신뢰성에 따라 분류

* 캐시(Cache)
    - 저장 장치 중에서 가장 빠르고 비싸다.
    - 캐시를 고려하는 것은 데이터 구조와 알고리즘 설계 단계에서 의미가 있다.
* 메인 메모리(Main memory)
    - 연산에 사용할 데이터를 저장하기 위한 장치.
    - 범용의 기계어도 사용하며, 휘발성(volatile)이다.
* 플래시 메모리(Flash Memory)
    - 비휘발성(non-volatile)
    - USB 메모리에 자주 사용한다.
    - SSD도 내부적으로 플래시 메모리를 사용하지만, 자기 디스크와 유사한 인터페이스를 제공한다. 
    - 블록 단위로 저장이 가능하여, 블록 지향 인터페이스(block- oriented interface)라 한다.
    - 블록의 크기는 일반적으로 512 바이트에서 8킬로바이트 사이이다.
* 자기 디스크 저장 장치
    - HDD와 같은 장치
* 광학 저장장치(DVD), 테이프 저장 장치 
    - 테이프 저장 장치는 안전하게 저장이 가능하나, 순차적 접근때문에 속도가 느리다.
    - SSD는 직접 접근 저장장치라 속도가 빠르다.
* 비용과 속도 사이의 Trade-off

## 12.2 저장 장치 인터페이스
* SATA ( 초당 6기가비트, 사실은 초당 최대 600메가 바이트)
* SCSI ( 버전3은 초당 12기가 바이트 )
* 비휘발성 메모리 익스프레스(NVMe)
* SAN(storage area network)
    * SCSI를 IP 네트워크로 제공하는 iSCSI, 파이버 채널, 인피니티 밴드
* NAS(network attacked storage) : SAN의 대안
    * NFS 또는 CIFS와 같은 네트워크 파일 시스템을 사용

## 12.3 자기 디스크

### 12.3.1 디스크의 물리적 특성
* 디스크 판(platter)
* 디스크 표면은 논리적으로 트랙(track)으로 나뉘고, 트랙은 다시 섹터로 나뉜다.
* 섹터는 디스크로부터 읽고 쓸 수 있는 정보의 가장 작은 단위.(512바이트, 디스크에 20억에서 240억 섹터)
* 외부트랙에 더 많은 섹터가 있음.
* 판독-기록 헤드 : 섹터에 정보 저장
* 디스크 암에 헤드가 올려져 있으며, 둘을 합쳐서 헤드-디스크 어셈블리
* 모든 헤드는 같이 움직여서, 같은 i번째 실린더에 기록함.

* 디스크 컨트롤러
    * 컴퓨터 시스템과 디스크 드라이버의 하드웨어를 연결
    * 디스크 컨트롤러에 체크섬이 구현되어 섹터에 쓰인 데이터를 비교한다.
    * 손상된 섹터의 재배치를 수행

### 12.3.2 디스크의 성능 측정
* 접근시간 : 읽기나 쓰기 요청시 전송 시작까지 걸리는 시간
* 탐색 시간: 암을 재위치시키는데 걸리는 시간
* 현재 디스크 시스템은 초당 50~200메가 바이트의 전송속도 
* 디스크 I/O 요청시 사용하는 주소는 디스크 블록 번호형식이다.
* 순차적 접근 유형 : 연속된 블록 번호
* 임의 접근 유형 : 각 요청에 탐색이 필요하다. 초당 I/O 연산 수(IOPS)는 블록 접근 수 크기 등에 따라서 다르다.
* 일반적으로 50~200 IOPS를 지원하고, 탐색당 소량의 데이터만 읽어서, 전송속도는 순차적 접근 유형보다 빠르다.
* MTTF : 실패없이 동작할 수 있는 시간

## 12.4 플래시 메모리

* NOR 플래시와 NANd 플래시가 있다.
* 플래시 변환 계층이라는 소프트웨어 계층이 페이지 주소 매핑, 페이지 정보 복제, 평등화 작업을 수행.
* 4킬로바이트 짜리 표준 블록에 대한 초당 임의 블록 읽기 수(10000IOPS)
* NVMe는 초당 350000개이상의 IOPS를 지원, QD-32는 32차 병렬 처리 지원

## 12.5 RAID

* 디스크의 성능과 신뢰성 향상을 위해 개발

### 12.5.1 중복에 의한 신뢰성 향상
* 디스크 실패 시 손실된 정보를 복원하지만 MTTF는 증가한다.
* MTTF가 100,000일때 100개 디스크로 구성된 하나의 배열에서 일부 디스크가 실패할 MTTF는 100000/100 = 1000시간이므로 42일.
* 복사본이 없다면 치명적인 데이터 손실 가능성이 있다.
* 한 디스크의 MTTF는 100,000 시간이고 데이터 복구 평균 시간이 10시간이면, 미러링된 디스크 시스템의 데이터 손실 평균 시간은 100,000^2/(2*10) = 500 * 10^6 시간, 즉 57000년

### 12.5.2 병렬화에 의한 성능 향상
* 디스크 미러링으로 읽기 요청 처리 속도는 2배가 된다.
* 복수개의 디스크로, 데이터 분산(striping)을 통해 속도 개선이 가능하다.
* 각 바이트의 비트를 복수의 디스크에 나누어 저장(bit-level-striping)
* 모든 디스크가 모든 접근에 참여하므로 초당 처리할 수 있는 접근 수는 같지만, 단일 디스크상에서 배로 데이터를 읽는다.
* 불록단위 분산 : 블록을 여러 개의 디스크에 분산. 디스크 배열을 하나의 큰 디스크로 여기고 블록에 논리적 번호를 부여
* n개의 디스크 배열에서 블록 단위 분산은 디스크 배열의 논리적 블록 i를 (i mod n)+1 디스크에 할당
* 즉 8개의 디스크 배열에서 블록 11은 디스크 4의 블록 1에 저장됨.
    * 작은 접근의 처리량을 증가시키기 위해 복수의 작은 접근을 부하 분산
    * 큰 접근에 대한 응답 시간응ㄹ 줄이기 위해 큰 접근은 별렬화

### 12.5.3 RAID 수준

* 디스크 분산을 패리티 비트로 결합함으로서 비용을 낮춤
* 패리티 블록의 i번째 비트를 XOR로 계산. 집합에 있는 블록 중 손실될 경우 나머지 블록의 비트별 XOR을 계산하여 복구
* RAID 수준 0 : 중복은 없으며 블록 단위로 분산
* RAID 수준 1 : 블록 분산을 하는 미러링 디스크
* RAID 수준 5 : N개의 논리적 블록과 한개의 패리티를 저장하여 N+1개의 디스크를 사용
* RAID 수준 6 : P + Q 방법이며 5수준과 흡사

### 12.5.4 하드웨어 사안
* 소프트웨어 RAID